








/*definición léxica*/
%{

%}

%lex
%options case-insensitive

%%
"."         return 'point';
".."        return 'twoPoint';
"#"         return  'hash';
"*"         return 'asterisk';
"("         return 'parIzq';
")"         return 'parDer';
"{"         return 'llaIzq';
"}"         return 'llaDer';
"?"         return 'Interrogacion';
":"         return 'colon';
"|"         return 'barra';
"||"        return 'or2';
"["         return 'corcheteIzq';
"]"         return 'corcheteDer';

"\"\""      return 'EscapeQuot';
"''"        return 'EscapeApos';
":="        return 'asignacion';
":*"        return 'colonAsterisk';
"*:"        return 'asteriskColon'
"::"        return 'doubleColon';
"+"         return 'add';
","         return 'comma';
"-"         return 'minus';
"=>"        return 'arrow';
"="         return 'equal';
"/"         return 'slash';
"/""/"      return 'doubleSlash';
"!"         return 'not';
"!="        return 'diferent';
"<"         return 'menor';
"<="        return 'menorIgual';
">"         return 'mayor';
">="        return 'mayorIgual';
"<<"        return 'quOpen';
">>"        return 'quClose'
"@"         return 'at';
//"$"         return 'dolar';
"as"        return 'as';
"eq"        return 'eq';
"ne"        return 'ne';
"lt"        return 'lt';
"le"        return 'le';
"gt"        return 'gt';
"ge"        return 'ge';
"is"        return 'is';
"to"        return 'to';
"of"        return 'of';
//"for"       return 'for';
"in"        return 'in';
//"if"        return 'if';
"or"        return 'or';
"let"       return 'let';
"and"       return 'and';
"div"       return 'div';
"mod"       return 'mod';
//"map"       return 'map';
"text"      return 'text';
"some"      return 'some';
//"then"      return 'then';
"item"      return 'item';
"node"      return 'node';
//"else"      return 'else';
"idiv"      return 'idiv';
"cast"      return 'cast';
"every"     return 'every';
"child"     return 'child';
"self"      return 'self';
"union"     return 'union';
//"array"     return 'array';
"treat"     return 'treat';
"return"    return 'return';
"parent"    return 'parent';
"comment"   return 'comment';
"element"   return 'element';
"except"    return 'except';
"function"  return 'function';
"castable"  return 'castable';
"instance"  return 'instance';
"ancestor"  return 'ancestor';
"namespace" return 'namespace';
"attribute" return 'attribute';
"preceding" return 'preceding';
"following" return 'following';
"intersect" return 'intersect';
//"satisfies" return 'satisfies';
"descendant" return 'descendant';
"document_node"  return 'document_node';
"empty_sequence" return 'empty_sequence';
"namespace_node" return 'namespace_node';
//"schema_element" return 'schema_element';
//"schema_attribute" return 'schema_attribute';
"ancestor_or_self"   return 'ancestor_or_self';
"descendant_or_self" return 'descendant_or_self';
"following_sibling"  return 'following_sibling';
"preceding_sibling"  return 'preceding_sibling';
"processing_instruction" return 'processing_instruction';
[0-9]+                      return  'digits';

<<EOF>>                 return 'EOF';
.       {
        console.error('Error');
}
/lex

/* Asociación de operadores y precedencia */
%left 'or2'
%left 'add', 'minus' /*binary*/
%left 'asterisk', 'div', 'idiv', 'mod'
%left 'intersect', 'except'
%left 'arrow'
%right 'minus', 'add' /*unary*/
%left 'not'
%left 'slash', 'doubleSlash'
%left 'parIzq', 'parDer', 'corcheteIzq', 'corcheteDer'



<
%start ini 
%% /*definicion de gramática*/
ini
    :XPATH EOF {}
;

XPATH
        :LIST_EXPR{}
;

/*PARAMLIST
        :PARAMLIST comma PARAM{}
        |PARAM{}
;
PARAM 
        :dolar EQNAME{}
        |dolar EQNAME TYPE_DECLARATION{}
;
FUNCTION_BODY
        :ENCLOSED_EXPR{}
;
ENCLOSED_EXPR
        :llaIzq EXPR llaDer{}
        |llaIzq  llaDer{}
;*/
EXPR
        :LIST_EXPR
;
LIST_EXPR
        :LIST_EXPR comma EXPR_SINGLE{}
        |EXPR_SINGLE{}
;
EXPR_SINGLE
        //:FOR_EXPR{}
        //|LET_EXPR{}
        //|QUANTIFIED_EXPR{}
        //|IF_EXPR{}
        :OR_EXPR{}
;
/*
FOR_EXPR
        :SIMPLE_FOR_CLAUSE return EXPR_SINGLE{}
;
SIMPLE_FOR_CLAUSE
        :for LIST_SIMPLE_FOR_BINDING{}
;*/

/*LIST_SIMPLE_FOR_BINDING
        :LIST_SIMPLE_FOR_BINDING comma SIMPLE_FOR_BINDING{}
        |SIMPLE_FOR_BINDING{}
;*/
//10
/*SIMPLE_FOR_BINDING
        :dolar EQNAME in EXPR_SINGLE{}
;*/
/*LET_EXPR
        :SIMPLE_LET_CLAUSE return EXPR_SINGLE{}
;

SIMPLE_LET_CLAUSE
        :let LIST_SIMPLE_LET_BINDING{}
;

LIST_SIMPLE_LET_BINDING
        :LIST_SIMPLE_LET_BINDING comma SIMPLE_LET_BINDING{}
        |SIMPLE_LET_BINDING{}
;*/

/*SIMPLE_LET_BINDING
        :dolar EQNAME asignacion EXPR_SINGLE{}
;*/

/*QUANTIFIED_EXPR
        : CADENA_EXPR LIST_QUANTI satisfies EXPR_SINGLE{}
;
CADENA_EXPR
        :some{}
        |every{}
;*/

/*LIST_QUANTI
        :LIST_QUANTI comma dolar EQNAME in EXPR_SINGLE{}
        |dolar EQNAME in EXPR_SINGLE{}
;*/
//15
/*IF_EXPR
        :if parIzq LIST_EXPR parDer then EXPR_SINGLE else EXPR_SINGLE{}
;*/
OR_EXPR
        :LIST_OR_EXPR{}
;

LIST_OR_EXPR
        :LIST_OR_EXPR or AND_EXPR{}
        |AND_EXPR {}
;
AND_EXPR
        :LIST_AND_EXPR{}
;

LIST_AND_EXPR
        :LIST_AND_EXPR and COMPAR{}
        |COMPAR{}
;
COMPAR
        :LIST_COMPAR{}
;
LIST_COMPAR
       // :LIST_COMPAR and COMPARISION_EXPR{}
        :COMPARISION_EXPR{}
;
COMPARISION_EXPR
        :STRING_CONCAT OPTION{}
        |STRING_CONCAT{}
;

OPTION
        : VALUES STRING_CONCAT{}
;

VALUES
        :VALUE_COMP{}
        |GENERAL_COMP{}
       // |NODE_COMP{}
;
STRING_CONCAT
        :LIST_RANGE_EXPRE
;
LIST_RANGE_EXPRE
        :LIST_RANGE_EXPRE or2 RANGE_EXPR{}
        |RANGE_EXPR{}
;

RANGE_EXPR
        :ADDITIVE_EXPR TO ADDITIVE_EXPR{}
        |ADDITIVE_EXPR{}
        
;
ADDITIVE_EXPR
        :LIST_MULTI_EXPR{}
        
;
LIST_MULTI_EXPR
        :LIST_MULTI_EXPR OPERADOR MULTI_EXPR{}
        |MULTI_EXPR{}
;

OPERADOR
        :add{}
        |minus{}
;
//20
MULTI_EXPR
        :LIST_UNION_EXPR{}
;
LIST_UNION_EXPR
        :LIST_UNION_EXPR OPERADOR_2 UNION_EXPR
        |UNION_EXPR
;
OPERADOR_2
        :asterisk{}
        |div{}
       // |idiv{}
        |mod{}
;
UNION_EXPR
        :LIST_INTERSECT_EXPECT{}
;
LIST_INTERSECT_EXPECT
        :LIST_INTERSECT_EXPECT OPERADOR_3 INTERSECT_EXPECT{}
        |INTERSECT_EXPECT{}
;
OPERADOR_3
        :union{}
        |barra{}
;
INTERSECT_EXPECT
        :LIST_INSTANCEOF_EXPR{}
;

LIST_INSTANCEOF_EXPR
        :LIST_INSTANCEOF_EXPR OPERADOR_4 INSTANCE_EXPR{}
     //   |INSTANCE_EXPR
        |ARROW_EXPR

;

OPERADOR_4
        :intersect{}
        |except{}
;

        
/*INSTANCE_EXPR
      //  : TREAT_EXPR instance of SEQUENCE_TYPE{}
        |TREAT_EXPR{}
;
//26
TREAT_EXPR
      //  :CASTABLE_EXPR treat as SEQUENCE_TYPE{}
        |CASTABLE_EXPR{}
;

CASTABLE_EXPR
       // :CAST_EXPR castable as SINGLE_TYPE{}
        |CAST_EXPR{}
;
CAST_EXPR
      //  :ARROW_EXPR cast as SINGLE_TYPE{}
        |ARROW_EXPR
;
LIST_ARROW_EXPR
        : LIST_ARROW_EXPR arrow ARROW_FUNCTION ARGUMENT_LIST{}
        |UNARY_EXPR{}
;
//30*/


ARROW_EXPR
        : UNARY_EXPR LIST_A{}
;
LIST_A
        :LIST_A U arrow ARROW_FUNCTION_SPECIFIER ARGUMENT_LIST{}
        |arrow ARROW_FUNCTION_SPECIFIER ARGUMENT_LIST{}
;

UNARY_EXPR
        :LIST_OP VALUE_EXPR{}
        |VALUE_EXPR{}
;
LIST_OP
        :LIST_OP OPERADOR{}
        |OPERADOR{}
;
VALUE_EXPR 
        :SIMPLE_MAP_EXPR{}
;
//32
GENERAL_COMP
        :equal{}
        |diferent{}
        |menor{}
        |menorIgual{}
        |mayor{}
        |mayorIgual{}
;
VALUE_COMP//
        :eq{}
        |ne{}
        |lt{}
        |le{}
        |gt{}
        |ge{}
;
/*NODE_COMP
        :is{}
        |quOpen{}
        |quClose{}
;*/
//35
SIMPLE_MAP_EXPR
        :LIST_PATH_EXPR
;
LIST_PATH_EXPR
        :LIST_PATH_EXPR not PATH_EXPR{}
        |PATH_EXPR{}
;
PATH_EXPR
        :OPTION_2{}
        |doubleSlash RELATIVE_PATH_EXPR{}
        |RELATIVE_PATH_EXPR{}
;

OPTION_2
        :slash RELATIVE_PATH_EXPR{}
        |slash{}
;
//37
RELATIVE_PATH_EXPR
        :LIST_STEP_EXPR{}
;
LIST_STEP_EXPR
        :LIST_STEP_EXPR OPERADOR_5 STEP_EXPR{}
        |STEP_EXPR{}
;
OPERADOR_5
        :slash{}
        |doubleSlash{}
;

STEP_EXPR
        :POSTFIX_EXPR{}
        |AXIS_STEP{}
;

AXIS_STEP//sii
        :OPTION_3 PREDICATE_LIST{}
;
OPTION_3//sii
        :REVERSE_STEP{}
        |FORWARD_STEP{}
;
//40
FORWARD_STEP//sii
        :FORWARD_AXIS NODE_TEST{}
        |ABBREV_FORWARD_STEP{}
;

FORWARD_AXIS//sii
        :child doubleColon{}
        |descendant doubleColon{}
        |attribute doubleColon{}
        |self doubleColon{}
        |descendant_or_self doubleColon{}
        |following_sibling doubleColon{}
        |following doubleColon{}
        |namespace doubleColon{}
;

//42
ABBREV_FORWARD_STEP//si
        :at NODE_TEST{}
        |NODE_TEST{}
;

REVERSE_STEP
        :REVERSE_AXIS NODE_TEST{}
        |twoPoint{}
;
REVERSE_AXIS//sii
        :parent doubleColon{}//sii
        |ancestor doubleColon{}
        |preceding_sibling doubleColon{}
        |preceding doubleColon{}
        |ancestor_or_self doubleColon{}
;
NODE_TEST
        :KIND_TEST{} //tipos
        |NAME_TEST{}
;
NAME_TEST       
        :EQNAME{}
        |WILDCARD{}
;
WILDCARD
        :asterisk{}
        |NC_NAME colonAsterisk{}
        |asteriskColon NC_NAME{}
        |BRACED_URI_LITERAL asterisk{}
;
//49
POSTFIX_EXPR
        :PRIMARY_EXPR LIST_OPTION_4{}
        |PRIMARY_EXPR{}
;
LIST_OPTION_4
        :LIST_OPTION_4 OPTION_4{}
        |OPTION_4{}
;
OPTION_4                
        :PREDICATE {}
        |parIzq parDer{}
        //|ARGUMENT_LIST{}
        //|LOOKUP{}
;
//50
/*ARGUMENT_LIST
        :parIzq LIST_ARGUMENT parDer{}
        |parIzq parDer{}
;
LIST_ARGUMENT
        :LIST_ARGUMENT comma ARGUMENT {}
        |ARGUMENT{}
;*/
PREDICATE_LIST
        : PREDICATE_LIST PREDICATE{}
        |PREDICATE{}
;

PREDICATE
        : corcheteIzq EXPR corcheteDer{}
;
/*LOOKUP 
        :Interrogacion KEY_SPECIFIER{}
;
KEY_SPECIFIER   
        :NC_NAME{}
        |digits{}
        |PARENTHESIZED_EXPR{}
        |asterisk{}
;*/
//55
ARROW_FUNCTION_SPECIFIER
        :EQNAME{}
       // |VAR_REF{}
        |PARENTHESIZED_EXPR{}
;

PRIMARY_EXPR
        :LITERAL {}
      //  |VAR_REF{}
        |PARENTHESIZED_EXPR{}
        |point{}
        |FUNCTION_CALL{}
        |FUNCTION_ITEM_EXPR{}
      //  |MAP_CONSTRUCTOR{}
        |ARRAY_CONSTRUCTOR{}
       // |LOOKUP{}
;
LITERAL
        :NUMERIC_LITERAL{}
        |STRING_LITERAL{}
;
NUMERIC_LITERAL 
        :digits{}
        |DECIMAL_LITERAL{}
        |DOUBLE_LITERAL{}
;
//*59
/*VAR_REF
        :dolar EQNAME{}
;*/

PARENTHESIZED_EXPR     
        :parIzq EXPR parDer{}
        |parIzq parDer{}
;

/*FUNCTION_CALL
        :EQNAME ARGUMENT_LIST{}
;*/
//64
/*ARGUMENT
        :EXPR_SINGLE{}
        |Interrogacion{}
;
FUNCTION_ITEM_EXPR
        :NAMED_FUNCTION_REF{}
        |INLINE_FUNCTION_EXPR{}
;
NAMED_FUNCTION_REF
        :EQNAME hash digits{}
;
INLINE_FUNCTION_EXPR
        :function OPTION_5 OPTION_6 {}
;
OPTION_5
       // :parIzq  PARAMLIST parDer{}
        :parIzq parDer{}
;
OPTION_6
        : as SEQUENCE_TYPE FUNCTION_BODY{}
        | FUNCTION_BODY{}
;
//69
MAP_CONSTRUCTOR
        :map llaIzq LIST_OPTION_7 llaDer{}
        |map llaIzq  llaDer{}
;
LIST_OPTION_7
        :LIST_OPTION_7 comma MAP_CONSTRUCTOR_ENTRY{}
        |MAP_CONSTRUCTOR_ENTRY{}
;

//70
MAP_CONSTRUCTOR_ENTRY
        :EXPR_SINGLE colon EXPR_SINGLE{}
;*/
//73
ARRAY_CONSTRUCTOR
        :SQUARE_ARRAY_CONSTR{}
      //  |CURLY_ARRAY_CONSTR{}
;
SQUARE_ARRAY_CONSTR
        :corcheteIzq LIST_OPTION_8 corcheteDer{}
        |corcheteIzq corcheteDer{}
;
LIST_OPTION_8
        :LIST_OPTION_8 comma EXPR_SINGLE{}
        |EXPR_SINGLE{}
;
//75
/*CURLY_ARRAY_CONSTR
        :array ENCLOSED_EXPR{}
;*/
//77
SINGLE_TYPE
        //:EQNAME Interrogacion{}
        :EQNAME{}
;
/*TYPE_DECLARATION
        :as SEQUENCE_TYPE{}
;
SEQUENCE_TYPE
        :empty_sequence parIzq parDer{}
        |ITEM_TYPE OCURRENCE_INDICATOR{}
        |ITEM_TYPE{}
;
OCURRENCE_INDICATOR
       // :Interrogacion{}
        :asterisk{}
        |add{}
;*/
ITEM_TYPE
        :KIND_TEST{}
        |item parIzq parDer{}
       // |FUNCTION_TEST{}
      //  |MAP_TEST{}
        //|ARRAY_TEST{}
        |EQNAME{}//sii
        |PARENTHESIZED_ITEM_TYPE{}
;
//83
KIND_TEST
        :DOCUMENT_TEST{}//1
        |ELEMENT_TEST{}//2
        |ATTRIBUTE_TEST{}//3
      //  |SCHEMA_ELEMENT_TEST{}
        //|SCHEMA_ATTRIBUTE_TEST{}
        |PI_TEST{}//6
        |comment parIzq parDer{}//7
        |text parIzq parDer{}//4
        |namespace_node parIzq parDer{}//5
        |node parIzq parDer{}
;
//85
DOCUMENT_TEST
        :document_node  parIzq OPTION_9 parDer{}
        |document_node  parIzq  parDer{}
;
OPTION_9
        :ELEMENT_TEST{}
     //   |SCHEMA_ELEMENT_TEST{}
;
//89
PI_TEST
        :processing_instruction parIzq OPTION_10 parDer{}
        |processing_instruction parIzq  parDer{}
;
OPTION_10
        :NC_NAME{}
        |STRING_LITERAL{}
;
ATTRIBUTE_TEST
        :attribute parIzq OPTION_11 parDer{}
        |attribute parIzq parDer{}
;
OPTION_11
        :ATTRIB_NAME_OR_WILD_CARD comma TYPE_NAME{}
        |ATTRIB_NAME_OR_WILD_CARD {}
;
ATTRIB_NAME_OR_WILD_CARD
        :EQNAME{}
        |asterisk{}
;
/*SCHEMA_ATTRIBUTE_TEST
        :schema_attribute parIzq EQNAME parDer{}
;*/
//94
ELEMENT_TEST
        :element parIzq OPTION_12 parDer{}
        |element parIzq parDer{}
;
OPTION_12
        :ELEMENT_NAME_OR_WILDCARD OPTION_13{}
        |ELEMENT_NAME_OR_WILDCARD{}
;
OPTION_13
        :comma TYPE_NAME Interrogacion{}
        |comma TYPE_NAME{}
;
//95
ELEMENT_NAME_OR_WILDCARD
        :EQNAME{}
        |asterisk{}
;
/*SCHEMA_ELEMENT_TEST
        :schema_element parIzq EQNAME parDer{}
;*/
//102
FUNCTION_TEST
        :function parIzq asterisk parDer{}
        |TYPED_FUNCTION_TEST{}
;
//104
TYPED_FUNCTION_TEST
        :function parIzq LIST_OPTION_14 parDer as SEQUENCE_TYPE{}
        |function parIzq  parDer as SEQUENCE_TYPE{}
;
LIST_OPTION_14
        :LIST_OPTION_14 comma SEQUENCE_TYPE{}
        |SEQUENCE_TYPE{}
;
//105
/*MAP_TEST
        :map parIzq asterisk parDer{}
        |map parIzq EQNAME comma SEQUENCE_TYPE parDer{}
;//108*/
/*ARRAY_TEST
        :array parIzq asterisk parDer{}
        |array parIzq SEQUENCE_TYPE parDer{}
;*/
//111
PARENTHESIZED_ITEM_TYPE
        : parIzq ITEM_TYPE parDer{}
;
EQNAME
        :QNAME{}
        |URI_QUALIFIFIED_NAME{}
;












        
















